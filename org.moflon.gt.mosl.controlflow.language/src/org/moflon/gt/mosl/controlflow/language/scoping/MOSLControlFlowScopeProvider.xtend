/*
 * generated by Xtext 2.11.0
 */
package org.moflon.gt.mosl.controlflow.language.scoping

import org.moflon.ide.mosl.core.scoping.ScopeProviderHelper
import org.eclipse.emf.ecore.EPackage
import org.apache.log4j.Logger
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.CalledPatternParameter
import org.moflon.ide.mosl.core.exceptions.CannotFindScopeException
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.MethodDec
import org.moflon.codegen.eclipse.CodeGeneratorPlugin
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.GraphTransformationControlFlowFile
import org.eclipse.emf.common.util.URI
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.EClassDef
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.ObjectVariableStatement
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.MethodParameter
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.PatternStatement
import org.moflon.gt.mosl.pattern.language.moslPattern.GraphTransformationPatternFile
import org.moflon.ide.mosl.core.scoping.utils.MOSLScopeUtil
import java.util.HashMap
import java.util.HashSet
import org.eclipse.emf.ecore.util.EcoreUtil
import java.io.File
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.moflon.gt.mosl.pattern.language.moslPattern.MoslPatternPackage
import java.util.List
import java.util.ArrayList
import org.eclipse.xtext.EcoreUtil2
import org.moflon.gt.mosl.controlflow.language.moslControlFlow.PatternReference
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MOSLControlFlowScopeProvider extends AbstractMOSLControlFlowScopeProvider {
	private ScopeProviderHelper<EPackage> scopeEPackageHelper = new ScopeProviderHelper()
	private ScopeProviderHelper<GraphTransformationPatternFile> scopeGTPF = new ScopeProviderHelper()
	private var resolvingCache = new HashMap<GraphTransformationControlFlowFile, List<GraphTransformationPatternFile>>();
	
	private Logger log = Logger.getLogger(MOSLControlFlowScopeProvider.getClass());
	
	override getScope(EObject context, EReference reference) {
	resolvePatterns(context)	
	try{
		if(searchForEClass(context,reference)){
			return getScopeByType(context, EClass)
		}
		else if(searchForEClassifier(context,reference)){
			return getScopeByType(context, EClassifier)
		}
//		else if(searchForCalledPatternParameter(context, reference))
//			return getScopeForCalledParameter(CalledPatternParameter.cast(context))
		else if(searchForPattern(context))
			return getScopeByPattern(context,reference)
//			return getScopeByType(context, PatternDef)
//		else if(searchForEReferences(context, reference)){
//			return getScopeByType(context, EReference)
//		}
	}catch (CannotFindScopeException e){
		log.debug("Cannot find Scope",e)
	}
		super.getScope(context, reference);
	}
	
	def boolean searchForCalledPatternParameter(EObject context, EReference reference) {
		return context instanceof CalledPatternParameter;
	}
	
	
	def resolvePatterns(EObject context)
	{
		val cfFile = MOSLScopeUtil.instance.getRootObject(context, GraphTransformationControlFlowFile)
		if(!resolvingCache.containsKey(cfFile)){
			val cfFileRes = cfFile.eResource
			val cfFileUri = cfFileRes.URI
			val cfFileURIStringPrefix = cfFileUri.toString.split("/").filter[part | !part.endsWith(".mcf")].fold("", [l,r | l + r + "/"])
			var patternUris = cfFile.includedPatterns.map[includedPattern | URI.createURI(cfFileURIStringPrefix+includedPattern.importURI)]
			val resSet = scopeEPackageHelper.resourceSet
			MoslPatternPackage.eINSTANCE.eClass
			val patternFiles = patternUris.map[uri | MOSLScopeUtil.instance.getObjectFromResourceSet(uri, resSet, GraphTransformationPatternFile)]
			patternFiles.filter[ptFile | ptFile.eIsProxy].forEach[ptFile | EcoreUtil.resolveAll(ptFile)]
			resolvingCache.put(cfFile, patternFiles)
		}
	}
//	def boolean searchForEReferences(EObject context, EReference reference) {
//		return context instanceof LinkVariablePattern && reference.name.equals("type")
//	}
	
	def boolean searchForPattern(EObject context) {
		return context instanceof PatternReference
	}
	
//	def IScope getScopeForCalledParameter(CalledPatternParameter cpp){
//		var method = MethodDec.cast(cpp.eContainer)
//		var candidates = getAllDefinitions(method)
//		
//		null 
//		
//	}
//	
//	def getAllDefinitions(MethodDec method){
//		var stack = new Stack<Statement>()
//		var candidates = new ArrayList<ObjectVariable>
//		stack.push(method.startStatement)
//		while(!stack.isEmpty){
//			var statement = stack.pop
//			if(statement instanceof NextStatement){
//				stack.push(statement.next)
//				if(statement instanceof ConditionStatement){
//					stack.push(statement.elseStartStatement)
//					stack.push(statement.thenStartStatement)
//				}
//				else if(statement instanceof LoopStatement){
//					stack.push(statement.loopStartStatement)	
//				}
//				else if(statement instanceof PatternStatement){
//					
//				}				
//			}				 
//				
//						
//		}
//		candidates
//	}


	def getScopeByPattern(EObject context, EReference reference) throws CannotFindScopeException{
		var gtf = MOSLScopeUtil.instance.getRootObject(context, GraphTransformationControlFlowFile)
		val patternFiles = resolvingCache.getOrDefault(gtf, new ArrayList())
		val type = reference.EType
		val candidates = patternFiles.map[ptFile | ptFile.eAllContents.filter[elem | elem.eClass === type].toList].flatten.toList
		Scopes.scopeFor(candidates)
	}
	
	def getScopeByType(EObject context, Class<? extends EObject> type)throws CannotFindScopeException{
		val set = scopeEPackageHelper.resourceSet
		CodeGeneratorPlugin.createPluginToResourceMapping(set);		
		var gtf = MOSLScopeUtil.instance.getRootObject(context, GraphTransformationControlFlowFile)//getGraphTransformationControlFlowFile(context)
		var uris = gtf.imports.map[importValue | URI.createURI(importValue.name)];
		return scopeEPackageHelper.createScope(uris, EPackage, type);		 
	}
	
	def boolean searchForEClass(EObject context, EReference reference){
		return context instanceof EClassDef 
	}
	
	def boolean searchForEClassifier(EObject context, EReference reference){
		return context instanceof MethodDec ||  context instanceof ObjectVariableStatement 
		|| (context instanceof MethodParameter && reference.name.equals("type"))
	}
}
